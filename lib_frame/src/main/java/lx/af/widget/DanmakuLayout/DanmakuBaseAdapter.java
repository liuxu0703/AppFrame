package lx.af.widget.DanmakuLayout;import android.view.View;import java.util.LinkedList;import java.util.List;import java.util.Random;/** * author: lx * date: 16-3-23 * * a bridge between {@link DanmakuLayout} and the underlying data for that view. */public abstract class DanmakuBaseAdapter<T> {    /** the order to display the data */    public enum PollDataMode {        /** first in first out */        FIFO,        /** last in first out */        LIFO,        /** random data in the list */        RANDOM,    }    /**     * get a View that displays the data.     * @param data a data within the adapter's data set.     * @param convertView the old view to reuse, if possible.     * @param parent the parent that this view will eventually be attached to.     * @return a View corresponding to the data.     */    public abstract View getView(T data, View convertView, DanmakuLayout parent);    /**     * @return animation duration for the view that presents the data.     */    public abstract long getDuration(T data);    /**     * get the type of View that will be created by {@link #getView} for the specified data.     * @return an integer representing the type of View. Two views should share     *         the same type if one can be converted to the other in {@link #getView}.     */    public abstract int getViewType(T data);    /**     * a callback method to be invoked when there is no data in the adapter.     */    public abstract void onDataEmpty();    /**     * set poll mode to indicate the order for the data to be displayed.     * default poll mode is {@link PollDataMode#FIFO}.     * @param mode the mode     */    public void setPollDataMode(PollDataMode mode) {        mPollMode = mode;    }    /**     * get poll mode, which indicates the order for the data to be displayed.     * default poll mode is {@link PollDataMode#FIFO}.     */    public PollDataMode getPollDataMode() {        return mPollMode;    }    /**     * add a danmaku data.     * the data will be displayed by order indicated by {@link PollDataMode}.     * data added by {@link #addDataHighPriority(Object)} will always be     * displayed earlier than added by this method.     * @see #addDataHighPriority(Object)     */    public final void addData(T data) {        synchronized (mDataLock) {            mNormalDataList.add(data);        }        if (mDanmakuLayout != null) {            mDanmakuLayout.onNewDataArrived();        }    }    /**     * add danmaku data list.     * the data will be displayed by order indicated by {@link PollDataMode}.     * data added by {@link #addDataHighPriority(List)} will always be     * displayed earlier than added by this method.     * @see #addDataHighPriority(List)     */    public final void addData(List<T> dataList) {        synchronized (mDataLock) {            mNormalDataList.addAll(dataList);        }        if (mDanmakuLayout != null) {            mDanmakuLayout.onNewDataArrived();        }    }    /**     * add a danmaku data with high priority.     * use this method to display a data immediately.     * @see #addData(Object)     */    public final void addDataHighPriority(T data) {        synchronized (mDataLock) {            mHighPriorityDataList.add(data);        }        if (mDanmakuLayout != null) {            mDanmakuLayout.onNewDataArrived();        }    }    /**     * add danmaku data list with high priority.     * use this method to display a set of data immediately.     * @see #addData(List)     */    public final void addDataHighPriority(List<T> dataList) {        synchronized (mDataLock) {            mHighPriorityDataList.addAll(dataList);        }        if (mDanmakuLayout != null) {            mDanmakuLayout.onNewDataArrived();        }    }    // =================================================    private DanmakuLayout mDanmakuLayout;    private LinkedList<T> mNormalDataList = new LinkedList<>();    private LinkedList<T> mHighPriorityDataList = new LinkedList<>();    private PollDataMode mPollMode = PollDataMode.FIFO;    private Random mRandom;    private final Object mDataLock = new Object();    void setDanmakuLayout(DanmakuLayout danmakuLayout) {        mDanmakuLayout = danmakuLayout;    }    DanmakuAnimator getDanmakuAnimator() {        T data = getNextData();        if (data == null) {            mDanmakuLayout.log("adapter, notify data empty");            onDataEmpty();            return null;        }        int type = getViewType(data);        long duration = getDuration(data);        DanmakuAnimator da = mDanmakuLayout.getRecycledAnimator(getViewType(data));        if (da != null) {            View convertView = da.getView();            View view = getView(data, convertView, mDanmakuLayout);            return da.reset(view, type, duration);        } else {            View view = getView(data, null, mDanmakuLayout);            return new DanmakuAnimator(view, type, duration);        }    }    protected T getNextData() {        synchronized (mDataLock) {            LinkedList<T> list;            if (mHighPriorityDataList.size() != 0) {                list = mHighPriorityDataList;            } else {                list = mNormalDataList;            }            if (list.size() != 0) {                switch (mPollMode) {                    case FIFO:                        return list.pollFirst();                    case LIFO:                        return list.pop();                    case RANDOM:                        if (mRandom == null) {                            mRandom = new Random();                        }                        int idx = mRandom.nextInt(list.size());                        T data = list.get(idx);                        list.remove(data);                        return data;                }            }        }        return null;    }    boolean hasData() {        return mNormalDataList.size() > 0;    }}